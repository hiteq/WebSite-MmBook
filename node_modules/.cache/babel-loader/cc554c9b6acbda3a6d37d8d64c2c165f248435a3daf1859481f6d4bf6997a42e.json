{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useDomEvent } from \"framer-motion\";\nimport { spring } from \"popmotion\";\nimport { mix } from \"@popmotion/popcorn\";\nimport { debounce } from \"lodash\";\n// Absolute distance a wheel scroll event can travel outside of\n// the defined constraints before we fire a \"snap back\" animation\nconst deltaThreshold = 5;\n// If wheel event fires beyond constraints, multiple the delta by this amount\nconst elasticFactor = 0.2;\nfunction springTo(value, from, to) {\n  if (value.isAnimating()) return;\n  value.start(complete => {\n    const animation = spring({\n      from,\n      to,\n      velocity: value.getVelocity(),\n      stiffness: 400,\n      damping: 40\n    }).start({\n      update: v => value.set(v),\n      complete\n    });\n    return () => animation.stop();\n  });\n}\nconst debouncedSpringTo = debounce(springTo, 100);\n/**\n * Re-implements wheel scroll for overlflow: hidden elements.\n *\n * Adds Apple Watch crown-style constraints, where the user\n * must continue to input wheel events of a certain delta at a certain\n * speed or the scrollable container will spring back to the nearest\n * constraint.\n *\n * Currently achieves this using event.deltaY and a debounce, which\n * feels pretty good during direct input but it'd be better to increase\n * the deltaY threshold during momentum scroll.\n *\n * TODOs before inclusion in Framer Motion:\n * - Detect momentum scroll and increase delta threshold before spring\n * - Remove padding hack\n * - Handle x-axis\n * - Perhaps handle arrow and space keyboard events?\n *\n * @param ref - Ref of the Element to attach listener to\n * @param y - MotionValue for the scrollable element - might be different to the Element\n * @param constraints - top/bottom scroll constraints in pixels.\n * @param isActive - `true` if this listener should fire.\n */\nexport function useWheelScroll(ref, y, constraints, onWheelCallback, isActive) {\n  _s();\n  const onWheel = event => {\n    event.preventDefault();\n    const currentY = y.get();\n    let newY = currentY - event.deltaY;\n    let startedAnimation = false;\n    const isWithinBounds = constraints && newY >= constraints.top && newY <= constraints.bottom;\n    if (constraints && !isWithinBounds) {\n      newY = mix(currentY, newY, elasticFactor);\n      if (newY < constraints.top) {\n        if (event.deltaY <= deltaThreshold) {\n          springTo(y, newY, constraints.top);\n          startedAnimation = true;\n        } else {\n          debouncedSpringTo(y, newY, constraints.top);\n        }\n      }\n      if (newY > constraints.bottom) {\n        if (event.deltaY >= -deltaThreshold) {\n          springTo(y, newY, constraints.bottom);\n          startedAnimation = true;\n        } else {\n          debouncedSpringTo(y, newY, constraints.bottom);\n        }\n      }\n    }\n    if (!startedAnimation) {\n      y.stop();\n      y.set(newY);\n    } else {\n      debouncedSpringTo.cancel();\n    }\n    onWheelCallback(event);\n  };\n  useDomEvent(ref, \"wheel\", isActive && onWheel, {\n    passive: false\n  });\n}\n_s(useWheelScroll, \"psOhxQYOHolCG88gbTip41Cwc50=\", false, function () {\n  return [useDomEvent];\n});","map":{"version":3,"names":["useDomEvent","spring","mix","debounce","deltaThreshold","elasticFactor","springTo","value","from","to","isAnimating","start","complete","animation","velocity","getVelocity","stiffness","damping","update","v","set","stop","debouncedSpringTo","useWheelScroll","ref","y","constraints","onWheelCallback","isActive","_s","onWheel","event","preventDefault","currentY","get","newY","deltaY","startedAnimation","isWithinBounds","top","bottom","cancel","passive"],"sources":["/Users/heetaekwoo/Documents/Github/WebSite-MmBook/src/utils/use-wheel-scroll.js"],"sourcesContent":["import { useDomEvent } from \"framer-motion\";\nimport { spring } from \"popmotion\";\nimport { mix } from \"@popmotion/popcorn\";\nimport { debounce } from \"lodash\";\n// Absolute distance a wheel scroll event can travel outside of\n// the defined constraints before we fire a \"snap back\" animation\nconst deltaThreshold = 5;\n// If wheel event fires beyond constraints, multiple the delta by this amount\nconst elasticFactor = 0.2;\nfunction springTo(value, from, to) {\n  if (value.isAnimating()) return;\n  value.start(complete => {\n    const animation = spring({\n      from,\n      to,\n      velocity: value.getVelocity(),\n      stiffness: 400,\n      damping: 40\n    }).start({\n      update: v => value.set(v),\n      complete\n    });\n    return () => animation.stop();\n  });\n}\nconst debouncedSpringTo = debounce(springTo, 100);\n/**\n * Re-implements wheel scroll for overlflow: hidden elements.\n *\n * Adds Apple Watch crown-style constraints, where the user\n * must continue to input wheel events of a certain delta at a certain\n * speed or the scrollable container will spring back to the nearest\n * constraint.\n *\n * Currently achieves this using event.deltaY and a debounce, which\n * feels pretty good during direct input but it'd be better to increase\n * the deltaY threshold during momentum scroll.\n *\n * TODOs before inclusion in Framer Motion:\n * - Detect momentum scroll and increase delta threshold before spring\n * - Remove padding hack\n * - Handle x-axis\n * - Perhaps handle arrow and space keyboard events?\n *\n * @param ref - Ref of the Element to attach listener to\n * @param y - MotionValue for the scrollable element - might be different to the Element\n * @param constraints - top/bottom scroll constraints in pixels.\n * @param isActive - `true` if this listener should fire.\n */\nexport function useWheelScroll(ref, y, constraints, onWheelCallback, isActive) {\n  const onWheel = event => {\n    event.preventDefault();\n    const currentY = y.get();\n    let newY = currentY - event.deltaY;\n    let startedAnimation = false;\n    const isWithinBounds =\n      constraints && newY >= constraints.top && newY <= constraints.bottom;\n    if (constraints && !isWithinBounds) {\n      newY = mix(currentY, newY, elasticFactor);\n      if (newY < constraints.top) {\n        if (event.deltaY <= deltaThreshold) {\n          springTo(y, newY, constraints.top);\n          startedAnimation = true;\n        } else {\n          debouncedSpringTo(y, newY, constraints.top);\n        }\n      }\n      if (newY > constraints.bottom) {\n        if (event.deltaY >= -deltaThreshold) {\n          springTo(y, newY, constraints.bottom);\n          startedAnimation = true;\n        } else {\n          debouncedSpringTo(y, newY, constraints.bottom);\n        }\n      }\n    }\n    if (!startedAnimation) {\n      y.stop();\n      y.set(newY);\n    } else {\n      debouncedSpringTo.cancel();\n    }\n    onWheelCallback(event);\n  };\n  useDomEvent(ref, \"wheel\", isActive && onWheel, { passive: false });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}